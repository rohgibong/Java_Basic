# JAVA 타입 형변환 원리 & 방법

---

### 타입 변환 (Type Conversion)

하나의 타입을 다른 타입으로 바꾸는 것을 타입 변환 혹은 형변환 이라고 한다.

프로그램에서 값의 대입이나 연산을 수행할 때는 같은 타입끼리만 가능하다. 그래서 같은 정수라도 타입이 다르면 연산을 수행하기 전에 같은 타입으로 만들어야하기 때문에 형변환 작업이 필요한것이다.

타입 변환에도 규칙이 있는데, 메모리에 할당받은 바이트의 크기가 상대적으로 작은 타입에서 큰 타입으로의 타입 변환은 생략할 수 있다. 하지만 메모리에 할당받은 바이트의 크기가 큰 타입에서 작은 타입으로의 타입 변환은 데이터의 손실이 발생하게 된다.

```java
short small_bowl; // 작은 그릇
int big_bowl; // 큰그릇

big_bowl = 200000000; // 2억
small_bowl = (short)big_bowl; // 큰 그릇을 작은 그릇에 강제로 물을 옮긴다.
System.out.println(small_bowl); // -15872 물이 넘쳐(데이터 손실) 이상한 값이 되었다.

small_bowl = 1000;
big_bowl = (int)small_bowl; // 작은 그릇의 물을 큰 그릇에 담는다.
System.out.println(big_bowl); // 1000 데이터 손실 없이 물을 잘 옮겨 담았다.
```

자바의 형변환 방법에는 크게 두가지 종류로 나뉜다.

개발자가 지정하지 않아도 자동적으로 이루어지는 **자동(묵시적) 형변환**과 개발자가 명시해야만 이루어지는 **강제(명시적) 형변환**이 있다. 이 두 형변환 종류는 다른 자료형 간의 연산시 어떤 자료형 그릇 크기에 맞추느냐에 따라 사용처가 달라지게 된다.

- 낮은 자료형으로 맞출 시 : 낮은 자료형으로 **강제 형변환**
- 높은 자료형으로 맞출 시 : 높은 자료형으로 **자동 형변환**

### 자동 형변환 ( Promotion )

자동 타입 변환은 묵시적/암시적 형변환 이라고도 불리우며, 프로그램 실행 도중에 컴파일러가 자동적으로 타입 변환이 일어나는 것을 말한다.

단, 작은 크기를 가지는 타입이 큰 크기를 가지는 타입에 저장될 때만 자동 타입 변환이 발생한다.

자바에서는 데이터의 손실이 발생하지 않거나, 데이터의 손실이 최소화되는 방향으로 자동 타입 변환을 진행하기 때문.

### 강제 형변환 ( Casting )

강제 형변환은 명시적 형변환이라고 불리우며, 사용자가 타입 캐스트 연산자(double)135 를 사용하여 값의 타입을 강제적으로 변환을 수행하는 것을 말한다.

작은 크기의 타입은 큰 크기의 타입으로 자동 형변환이 되지만, 반대로 큰 크기의 타입은 작은 크기의 타입으로 자동 타입 변환을 할 수 없다.

```java
int num = 60000;
byte value = (byte)num;    // 데이터 손실 발생
System.out.println(value); // 96

int num2 = 10;
byte value2 = (byte)num2;    // 데이터 손실 발생하지 않음
System.out.println(value2); // 10
```

주의할 점은, 강제적인 동작이므로 만일 데이터의 손실이 일어난다면 정확한 연산을 수행할 수 없기 때문에 예상하지 못한 결과를 얻을 수 있다는 것이다.

```java
byte b = 100;
byte b = (byte)100; // byte의 범위는 -128 ~ 127이기 때문에 데이터 손실 없이 대입이 가능하고 컴파일러가 자동 형변환을 해준다.

---------------------------------------

int i = 100;
byte b = i; // 에러, 변수이기 떄문에 상수일 때랑 다르다. 컴파일러는 변수 안에 값을 알지 못하기 때문에
byte b = (byte)i;

---------------------------------------

byte b = 1000; // 에러, byte 타입의 범위를 넘었기 때문에 자동 형변환 x
byte b = (byte)1000; // b에 -24가 대입된다.
```

실수 타입을 정수 타입으로 강제 타입 변환하면 소수점 이하의 데이터들은 버려진다.

```java
double dbNum = 12.3456;
int num = (int)dbNum; // 12
```

캐스트 연산자를 사용한 형변환은 일시적이기 때문에 피연산자의 자체 자료형에는 영향을 주지 않는다.

그리고 기본 자료형 중 boolean을 제외하면 모든 자료형은 형변환이 가능하다.

### 강제 타입 변환에 따른 정밀도 손실

강제 타입 변환에서 데이터 자체 손실 외에도 또 다른 주의점이 있다.  정수 타입을 실수 타입으로 변환할 때 정밀도 손실을 피해야 한다. 다음 예제를 보자.

```java
int num1 = 123456780;
int num2 = 123456780;

float num3 = num2;
System.out.println(num3); // 1.23456784 * E8

num2 = (int)num3;
System.out.println(num2); // 123456784

int result = num1 - num2;
System.out.println(result); // -4
```

int 타입 변수 num1과 num2에 동일한 123456780 값을 저장시키고, num2를 float 타입으로 변환시킨 후, 다시 int 타입으로 변환해서 num2에 저장했다.  그리고 num1에서 num2를 뺀 결과를 변수 result에 저장하고 콘솔에 출력한다.

동일한 값을 뺐기 때문에 당연히 0이 출력되어야 할 것이다. 하지만 실행 결과를 보면 엉뚱하게도 0이 나오질 않는다.

이러한 결과가 나온 이유는int 값을 float 타입으로 자동 변환하면서 문제가 발생했기 때문이다.

int 값을 손실 없이 float 타입의 값으로 변환할 수 있으려면 가수 23비트로 표현 가능한 값이어야 한다.

하지만 가수(23bit)가 최대로 표현할수 있는 값은 16,777,215 이다. 때문에 123,456,780은 23비트로 표현할 수 없기 때문에 근사치로 변환된다.

즉 정밀도 손실이 발생한 것이다. 그래서 위으 코드에서 float 값을 다시 int 타입으로 변환했어도 원래의 int 값을 얻지 못한 것이다.

이에 대한 해결책은 모든 int 값을 실수 타입으로 안전하게 변환시키는 double 타입을 사용하는 것이다. double 타입은 다음과 같이 가수부가 52비트나 할당되어 있으니 int형을 충분히 커버하고도 남는다.

### 형변환 안전장치

강제 형변환의 문제점인 데이터 손실을 방지하기 위해, 자바는 코드에서 데이터 값을 검사하기 위한 모든 기본 타입에 대해 최대값(max)과 최소값(min)을 다음과 같이 상수로 제공하고 있다. (boolean과 char 타입 제외)

이를 이용하여 어떤 정수값과 실수값을 다른 타입으로 변환하고자 할 때, 변환될 타입의 최소값과 최대값을 벗어나는지 검사하고, 만약 벗어난다면 타입 변환을 하지 않는 식으로 타입 변환 가드를 칠 수 있다.

```java
int i = 128;

if( (i < Byte.MIN_VALUE) || (i > Byte.MAX_VALUE) ) {
	System.out.println("byte 타입으로 변환 할 수 없음"); // 실행 (byte의 최대 크기는 127)
} else {
	byte b = (byte) i;
    System.out.println(b);
}
```

### 참고

[https://inpa.tistory.com/entry/JAVA-☕-타입-형변환-종류-방법-💯-총정리](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%ED%83%80%EC%9E%85-%ED%98%95%EB%B3%80%ED%99%98-%EC%A2%85%EB%A5%98-%EB%B0%A9%EB%B2%95-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC)
